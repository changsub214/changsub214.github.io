---
title: "Network Security 4장"
categories:
  - ns
tags:
  - study
  - networksecurity
toc: true
toc_sticky: true
use_math: true
---

> 본 글은 학교에서 '네트워크 보안'을 수강하면서 내용을 정리한 글입니다.

## 네트워크 보안 응용

### 원격 사용자 인증 원칙

+ 인증 단계
    - 식별 단계(Identification step)
        + 보안 시스템에 식별자 제시하기
            - 식별자는 주의해서 지정
            - 인증된 신원은 접근 통제 서비스 같은 추가적인 보안 서비스에 대한 기본조건이기 때문
    - 검증 단계(Verification step)
        + 개체와 식별자를 묶어서 입증할 수 있도록 인증 정보 제시 및 생성(Alice, Toklas, ABTOKAS, 패스워드(비밀, 엘리스와 시스템만 앎))

#### NIST의 전자 사용자 인증 모델

+ NIST SP800-63-2(Electronic Authentication Guideline)
+ 전자 사용자 인증
    - 전자적으로 정보 시스템에 제시된 사용자 신원에 대해 신뢰를 확립하는 과정
+ 시스템은 인증된 신원을 이용하여 인증된 개체가 특정 기능을 수행할 수 있도록 허가할지 말지를 결정
    - 특정 기능이란, 데이터베이스 트랜잭션이나 시스템 자원에 대한 접근

#### SP800-63-2 E-인증 구조 모델

<img src="/assets/image/ns-image/ns-019.png" width="100%" height="100%">

+ 등록기간(RA : Registration Authority)
+ 자격 서비스 제공자(CSP : Credential Service Provider)
+ 의존자(RP : Relying Party)

#### 사용자 신원 인증 방법

+ 개인이 알고 있는 것(Something the individual knows)
    - 패스워드 개인 식별 번호(PIN : Personal Identification Number), 사전에 작성된 질의에 대한 응답
+ 개인이 소지하고 있는 것(Something the individual possesses)
    - 암호 키, 전자 키 카드, 스마트 카드, 물리적 키 등 
    - 위와 같은 유형의 인증자를 `토큰(token)`이라 함
+ 개인 자체(정적 생체정보)(Something the individual is)
    - 지문, 망막, 안면 등을 통한 인식
+ 개인이 수행하는 것(동적 생체정보)(Something the individual possesses)
    - 음성패턴, 수기한 문자, 타이핑 리듬 등에 의한 인식

### 대칭 암호를 이용한 대칭키 분배

#### 대칭 암호를 이용한 대칭키 분배

1. A가 키를 선택한 뒤 B에게 직접 전달
2. 제 3자가 키를 선택한 뒤에 A와 B에게 직접 전달
3. A와 B의 공유키로 한 사람이 새 키를 작성하고 공유키로 암호화하여 상대방에게 전송
4. A와 B가 제 3자인 C와 암호화된 연결이 확립되어 있다면, C가 암호화된 링크를 통해서 A와 B에게 키를 전달

#### 4번째 방법에서 키 사용

+ 세션키(Session Key)
    - 세션이라고 하는 논리적 연결이 유지되는 동안 모든 사용자 데이터는 일회용 세션키로 암호화
    - 한 세션에만 사용
+ 영구키(Permanent Key)
    - 영구 키는 세션키 분배에 필요한 키
    - 복수회 사용
    - 키 분배 센터(KDC: Key Distribution Center)에서 활용

#### KDC 키 분배 절차

+ KDC는 통신 권한 여부 결정, 일회용 세션 키 제공

1. A가 B와 통신을 원하면 연결 요청 패킷을 KDC에 전송한다.
    - A와 KDC 사이의 통신은 A와 KDC가 공유하고 있는 마스터키로 암호화
2. KDC가 연결요청 후 KDC는 일회용 세션키 생성
    - 세션키를 A와 공유하고 있는 영구키로 암호화한 다음 A에게 전송
    - 동일한 방법으로 KDC는 이 세션키를 B와 공유하고 있는 영구키로 암호화한 뒤 B에게 전송
3. A와 B는 논리적 연결 가능
    - 세션키를 이용하여 데이터를 암호화하여 전송

### Kerberos

+ MIT에서 개발
+ 키 분배
+ 사용자 인증 서비스

#### 네트워크에 대한 위협

+ 위협
    - 사용자로 위장
    - 네트워크 주소 변경
    - 재전송 공격
+ 방어수단
    - Kerberos
        + 대칭 암호로만 구성
        + Version 4 
        + Version 5 - Version 4의 보안취약성을 보완
            + RFC4120

#### Kerberos Version 4

+ 내부 암호로 DES를 사용
+ Athena 프로젝트의 Bill Bryant가 사용한 방법으로 구조 설명
    - 가상적 절차 제시
    - 문제점 파악
    - 문제점 보완
    - 새 가상적 절차 제안

##### 들어가기전..

+ 인증서버(AS : authentication Server) 이용
    - AS는 각 서버와 유일한 비밀키를 공유
    - 비밀키는 안전한 방법으로 분배
        + 직접전달

##### 첫번째 가상 절차

수식정리

##### $ID_V$와 $ID_C$사용 목적

+ 변경이나 위조를 막기 위해 티켓 암호화
+ 서버 ID($ID_V$가 티켓에 포함되어 있기 때문에 서버는 그 티켓이 올바르게 복호화 되었는지를 확인 가능
+ 티켓이 C에게 발행되었다는 것을 명시하기 위해 티켓 속에 $ID_C$를 포함

##### $AD_C$ 사용 목적

+ 티켓을 요청한 워크스테이션에서만 티켓을 사용할 수 있게 함
+ $AD_C$는 C의 네트워크 주소

##### 보다 안전한 인증 절차

+ 인증 문제 해결
+ 아직 해결되지 않은 문제
    - 입력패스워드 수 과다
        + 서버 접속 마다 매번 패스퉈드 입력
        + 해결방법 - 티켓 재사용
        + 문제는 다른 서버 접속시 패스워드 입력
    - 패스워드를 평문으로 전송
        + 도청 가능
        + 해결방법 - `티켓발행서버(TGS: Ticket-Granting Server)` 도입

##### 가능한 공격 시나리오

+ 티켓을 가로챈 뒤 해당 사용자가 워크스테이션에서 로그오프 할 때까지 대기
+ 공격자는 자신의 워크스테이션 주소를 조작해서 공격 대상 컴퓨터와 동일 주소 갖도록 조작
+ 티켓을 재사용하여 TGS를 속임


대비책
+ 티켓 안에 타임스탬프 포함
    - 티켓 발행 시점 표기
    - 티켓 유효기간 표기

##### 개선된 가상적 절차

+ 사용자 로그온 세션마다 한 번

$(1) C `\rightarrow` AS: ID_C || IC_{tgs}$

$(2) AS `\rightarrow` C: E(K_C, Ticket_{tgs})
$
    - $Ticket_{tgs}$ : 티켓 승인 티켓(Ticket-granting ticket)
+ 서비스 유형마다 한 번 
$(3) C `\rightarrow` TGS: ID_C || ID_V || Ticket_{tgs}$
$(4) TGS `\rightarrow` C: Ticket_V$
    - $Ticket_V$ : V가 사용하기 위한 것, 서비스 승인 티켓(Service-granting ticket)

$
Ticket_{tgs} = E(K_{tgs},[ID_C || AD_C || ID_{tgs} || TS_1 || Lifetime_1])$
$Ticket_{V} = E(K_V,[ID_C || AD_C || ID_V || TS_2 || Lifetime_2])
$

+ 서비스 세션마다 한 번

(5) $C `\rightarrow` V: ID_C || Ticket_V$

$
Ticket_{tgs} = E(K_{tgs},[ID_C || AD_C || ID_{tgs} || TS_1 || Lifetime_1])$
$Ticket_{V} = E(K_V,[ID_C || AD_C || ID_V || TS_2 || Lifetime_2])
$

$TS_i$ : 타임스탬프 
$Lifetime_i$ : 유효기간

##### 티켓-승인 티켓의 유효기간 문제

+ 사용자의 반복적인 패스워드 입력으로 인한 불편 또는 재전송 공격 가능
+ 서비스-승인 티켓의 유효기간도 동일한 위험(공격자가 서비스에 접근 가능)
+ 티켓 제시자와 티켓 발행 받은 자의 동일성 확인 필요

> How to solve?
>> AS와 TGS가 공유하는 비밀값(세션키) 활용 
    - 분배방법이 필요

##### 서버를 사용자에게 인증하는 절차 부재

+ 특정 서버로 전달되는 메시지를 다른 곳으로 송신
+ 위장 서버 가능
+ 사용자로부터의 정보 갈취
+ 사용자에게 제공되는 서비스 방해

##### 더욱 개선된 방법(Kerberos Ver 4)

1. 인증서비스 교환 : 티켓-발행 티켓 취득


$C `\rightarrow` AB: ID_C || ID_{tgs} || TS_1$

$AB `\rightarrow` C : E(K_C || K_{Ctgs} || ID_{tgs} || TS_2 || Lifetime_2 || Ticket_{tgs}$

$Ticket_{tgs} = E(K_{tgs}, [K_{Ctgs} || ID_C || AD_C || ID_{tgs} || TS_2 || Lifetime_2])$

$K_{Ctgs}$ : 세션 키 

2. 티켓-발행 서비스 교환 : 서비스-발행 티켓 취득

수식입력


$K_{tgs}$ : AS, TGS 공유


$K_{Ctgs}$ : C, TGS 세션키


$Authenticator_C$ : 일회용


3. 클라이언트/서버 인증 교환 : 서비스 취득

    $C `\rightarrow` V : Ticket_V || Authentication_C$

    $V `\rightarrow` C : E(K_{C,V}, [TS_5 +1]$

    $Tickt_V = E(K_V, [K_{C,V} || ID_C || AD_C || ID_V || TS_4 || Lifetime_4$

    $Authenticator_C = E(K_{C,V},[ ID_C||AD_C||TS_5])$

#### Kerberos 개요

<img src="/assets/image/ns-image/ns-020.png" width="100%" height="100%">

#### Kerberos 교환

<img src="/assets/image/ns-image/ns-021.png" width="100%" height="100%">

+ 티켓 발행 서버에서 (AS) 부분 (TGS)로 정정!

#### Kerberos Version 4 Protocol

<img src="/assets/image/ns-image/ns-022.png" width="100%" height="100%">

<img src="/assets/image/ns-image/ns-023.png" width="100%" height="100%">

<img src="/assets/image/ns-image/ns-024.png" width="100%" height="100%">

<img src="/assets/image/ns-image/ns-025.png" width="100%" height="100%">

<img src="/assets/image/ns-image/ns-026.png" width="100%" height="100%">

#### Kerberos 공동체와 다중 Kerberi

+ 완전한 Kerberos 환경 조건
    - Kerberos 서버는 반드시 ID(UID : User ID)와 모든 사용자의 해시된 패시워드를 데이터베이스에 저장
    - 모든 사용자는 Kerberos 서버에 등록
    - Kerberos 서버는 필히 각 서버들과 비밀키를 공유
    - 모든 서버는 Kerberos 서버에 등록
+ Kerberos 공동체(realm aka. 영역)
    - 여러개의 공동체간 서비스 가능
        + Kerberos Master System(= Kerberos Database)
        + Kerberos Matser Password
        + Kerberos Principal(주체)
            + 서비스 또는 사용자 이름 + 인스턴스 이름 + 공동체 이름
+ 완전한 Kerberos 환경 추가 조건
    - 상호 교류하는 각 공동체에 속한 Kerberos 서버들은 다른 공동체 서버들과 비밀키를 공유
    - 두 개의 Kerberos 서버는 상호간에 등록

#### Kerberos Version 5

+ Version 5 : RFC 1510 
    - RFC 4120 으로 업데이트 됨

#### Version 4 와 5의 차이점

+ 환경적 결함
    - 암호화 시스템 의존성(Encryption system dependence) 
        + 4에서는 DES만 가능
        + 5에서는 모든 종류의 암호기술 사용
    - 인터넷 프로토콜 의존성(Internet protocol dependence)
        + 5에서는 모든 유형의 네트워크 주소 사용
    - 메시지 바이트 순서(Message byte ordering)
        + 4에서는 보내는 사람이 순서를 결정하고 보냄
        + 5에서는 ASN.1 과 BEP 인코딩 규칙 표준 사용
    - 티켓 유효기간(Ticket lifetime)
        + 5에서는 시작시간과 끝시간 표시
        + 유효기간이 따로 없다봐도 됨
    - 인증 전달(Authentication forwarding)
        + 4에서는 불가능했지만 5에서는 가능
    - 공동체간 인증(Interrealm authentication)
        + 5에서는 Kerberos대 Kerberos의 상호인증 가능
+ 기술적 결함
    - 이중 암호화(Double encryption)
        + 두번째 암호화는 필요 없음
    - PCBC 암호화(PCBC encryption)
        > What is PCBC?
        >> 확산암호블록체인(Propagating Cipher block chaining)
        >> <br>4에서는 비표준모드의 DES 사용
        >> <br>5에서는 표준모드의 CBC 사용
    - 세션키(Session keys)
        + 재전송 공격 위험이 있음
        + 5에서는 단 1회만 사용되는 서브세션키 협상 가능
    - 패스워드 공격(Password attacks)
        - 5에서는 패스워드 추측 기능이 더 어렵도록 만들어짐(사전인증 기능)

#### Version 5 인증 절차

1. 인증 서비스 교환 : 티켓-발행 티켓 취득
2. 티켓-발행 서비스 교환 : 서비스-발행 티켓 취득
3. 클라이언트/서버 인증 교환 : 서비스 취득

##### 인증 서비스 교환

수식

+ 티켓-발행 티켓(= 티켓-승인 티켓)



###