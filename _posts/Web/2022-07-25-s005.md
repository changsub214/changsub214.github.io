---
title: "여름방학 웹스터디 #05"
categories:
  - Web
tags:
  - study
  - web
  - js
toc: true
toc_sticky: true
---

> 이 글은 웹스터디 내용을 정리한 글입니다.

### Node.js

+ Node
    - 브라우저 밖에서 사용되는 JS
    - DOM, 사용자이벤트 같은 것들은 사용불가 (브라우저 내에서만 작동)
+ Node.js
    - JS의 런타임
    - node를 실행하면 REPL에 있게된다 웹브라우저의 콘솔과 동일
    - `global`이 node의 최상위객체

```javascript
// 명령줄에서 인수를 얻는 코드
const args = process.argv.slice(2); // 인덱스0은 node의 위치 인덱스1은 현 파일 위치
for(let i of args){
    console.log(`Hi there, I'm ${i}`);
} 
// 해당 파일명은 a.js 라 한다
// 터미널에서 node a.js changseop changsoon 입력
// HI there, I'm changseop
// Hi there, I'm changsoon

// 디렉터리를 비도익, 동기로 생성하는 코드
const fs = require('fs'); // fs를 불러오는 것

//async
fs.mkdir('dog', { recursive : true}, (err) => {
    if(err) throw err;
})

//sync
fs.mkdirSync('cat');
console.log("HAHAHAHAHA!");

```

### Modules & NPM

+ NPM 
    - Node Package Manager
    - 편리하게 라이브러리를 받을 수 있게 함
        + 예를들어 React, Express 가 있다
    - 패키지는 대게 지역화해서 섪치하게되는데 이는 버전관리 때문에 그렇다
    - 글로벌화해서 패키지를 받을 수 있는데 `npm i -g ~~~`라 하면 된다
        + 어떤 패키지들은 전역을 권장함
+ Modules
    - Node에서는 index.js가 진입점임 만약 전체디렉터리를 보낸다면 Node는 index.js를 찾게되고 이 파일이 보내는게 바로 index.js가 속한 디렉터리가 보내는 항목이 되는 것
+ pacakge.json
    - `npm init` 하면 생성되는 파일로 일반적으로는 패키지 설치시 디펜던시가 있는지 확인하고 속하는 패키지 설치를 위해 존재해야하는 파일
    - `npm i`, `npm install` 라 한 뒤 package.json 내에 명시된 디펜던시 모두 다운되면서 진행하는게 일반적

```javascript
// 모듈화하는 코드
//math.js
const add = (x,y) => x+y;
const PI = 3.1459;
const square = x => x*x;
//module.exports 라는 객체에 담기는 것
module.exports.add = add;
module.exports.PI = PI;
module.exports.square = square;
//아래처럼 단축가능
exports.add = add;
exports = "asddssda"; // 이렇게는 안됨! exports라는 변수화가 되기 때문


//app.js
const {PI, square} = requre('./math'); // .js 붙일 필요 없음, 이렇게 객체를 분해할 수 있음
console.log(PI);
console.log(square(5));

```

### Express

+ Express
    - 웹 개발 프레임워크로 Node로 서버를 생성하고 실행할 수 있음
+ 라이브러리 vs 프레임워크
    - 공통점은 타인이 작성한 코드라는 것
    - 라이브러리는 언제든지 내가 작성한 코드에 결합가능, 제어권을 내가 가짐
    - 프레임워크에서는 내가 제어를 거의 관여하지 않음 프레임워크의 작동원리에 따라 내 코드가 작동될 뿐(제어의 역전)
    - 프레임워크에서는 정해진 구조가 있는만큼 코드 작성에 있어서 유연성과 자유를 놓치게 됨

```javascript
const express = require('express');
const app = express();

app.use((req,res) => { //들어오는 요청이 있을때마다 반응
    // 모든 요청에대한 응답이고 HTTP 응답은 요청 한번에 응답 한번!
    console.log("HELLO!!!");
    res.send("HELLO, WE GOT YOUR REQUEST!");
    res.send({color : 'red', name : 'blahblah'});
    res.send('<h1> THIS IS HTML?! </h1>');
})

app.listen(8080, ()=>{ // 8080포트로 서버 오픈
    console.log("OHHHHHHHHH!!");

})

// routing
// get요청에만 응답
app.get('/', (req,res) => { // root route
    res.send('THIS IS MAIN PAGE');
})

app.get('/cats', (req,res) => {
    res.send('MEOW!!!!');
})

app.get('/dogs', (req,res) => {
    res.send('WOOF!!!!');
})

app.get('*', (req,res) => { //  마지막에 와야한다
    // 그렇지않으면 이 응답을 받고 아래에 존재하는 응답에 속하더라도 
    // 한번 응답했기때문에 무시되기 때문
    res.send('THIS IS NO PATH!!');
})
//posr 요청에 응답
app.post('/cats', (req,res) => {
    res.send('POST~~~~~~MEOW~~!');
})

// 제네릭 패턴
app.get('/r/:subreddit', (req,res) => { // : 는 변수를 의미
    const { subreddit } = req.params;
    res.send(`THIS IS ${subreddit} page!`);
})

// 쿼리 이용 코드
app.get('/search', (req,res) => {
    const { q } = req.query; // express가 대신 파싱하고 처리
    res.send(`HI, THIS IS ${q} !`);
})

```

+ Nodemon
    - Node 대신하여 파일의 변경사항이 있는지 확인 후 필요시 자동으로 서버 재시작해줌
    - 패키지 일종
    - `npm i nodeman`

### 템플레이팅

+  EJS
    - Embedded JavaScript 
    - HTML 내 템플릿 
    - 디폴트는 현 작업중인 디렉터리에 기반한 `/views` 로 되어 있다
    - 로직을 더하고 데이터를 보충하기 위해 사용

```javascript

const express = require('express');
const app = express();
const path = require('path');
const redditData = require('/ex.json');

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views')); // 현 디렉터리를 벗어나서도 작동할 수 있게 경로 설정하는 것

app.get('/', (req,res) => {
    res.render('home'); // view를 렌더링하고 렌더링 된 HTML 문자열을 클라이언트에 보냄
})

app.get('/random', (req,res) => { //템플릿에 데이터 전달하는 예
    const num = Math.floor(Math.random() * 10) +1;
    res.render('random', {rand : num}); // 키-값 구조의 객체 전달 가능
})

app.get('/r/:subreddit' , (req,res) => {
    const { subreddit } = req.params;
    const data = redditData[subreddit];
    if(data) {
        res.render('subreddit', {...data}); // data내 객체를 구조화하여 정보 전달
    }else {
        res.render('notfound', subreddit);
    }

})

app.get('/cat', (req,res) => {
    const  cats = { 'tovi', 'nami', 'groove', 'sowhan'};
    res.render('cats', {cats});
})

app.listen(8080, ()=>{ // 8080포트로 서버 오픈
    console.log("OHHHHHHHHH!!");

})

```

```html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1> My number is : <%= rand %> </h1> /* 렌더링하고 문서에 값을 넣음 */
    <% if(rand % 2 === 0 ) { %>  /* 렌더링되어 코드로만 작동할 뿐 */
        <h2> This is even num!</h2>
    <% } else { %>
        <h2> This is odd num!</h2>
    <% }  %>

    <ul>
    <% for(let cat of cats) { %>
        <li> <%= cat %> </li>
    <% } %>
    </ull>
</body>
</html>

```

+ express.static
    - 정적 파일을 제공하는 방법
    - 미들웨어

```javascript

const express = require('express');
const app = express();

app.use(express.static(path.join(__dirname, 'assets')));

```

### Define RESTfull Route

+ Get vs Post
    - Get은 정보 가져올 때 
    - Get은 리소스나 페이지를 요청하는 경우 언제나 사용
    - Post는 정보를 보낼 때
    - Post는 쿼리뿐만이 아닌 jSON으로도 보낼 수 있고 텍스트형식으로 보냄

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src = "index.js"></script>
    <title>Document</title>
</head>
<body>
    <h1>GET AND POST REQUEST</h1>
    <h2>GET</h2>
    <form action="https://localhost:3000/tacos" method="get">
        <input type = "text" name = "meat">
        <input type = "text" name = "qty">
        <button>Submit</button> 
    </form>
    <h2>POST</h2>
    <form action="https://localhost:3000/tacos" method="post">
        <input type = "text" name = "meat">
        <input type = "text" name = "qty">
        <button>Submit</button> 
    </form>

</body>
</html>
```

```javascript
const express = require('express');
const app = express();

app.use(express.urlencoded({extended : true}));
app.use(express.json()); // json 형식의 post시 body 객체화

app.get('/tacos', (req,res) => {
    console.log('get send !');
})

app.post('/tacos', (req,res) => {
    const {meat, qty}  = req.body;
    res.send(`OK, here your are ${qty} ${meat} tacos`);
})

app.listen(3000,  () => {
    console.log("ON PORT 3000");
})

```

+ REST
    - Representational State Transfer 
    - 분산 하이퍼미디어 시스템의 아키텍쳐 혹은 패러다임
    - 클라이언트와 서버가 어떻게 소통해야하는지에 대한 가이드라인 정도라 생각하면 됨
+ RESTful
    - REST 규칙에 따르는 시스템


```javascript
//RESTful 연습

const express = require('express');
const app = express();
const path = require('path');

app.use(express.urlencoded({extended : true}));
app.use(express.json()); // json 형식의 post시 body 객체화
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

let comments = [
    {
        id : 1,
        username : 'Todd',
        comment : 'lol that is so funny'
    },
    {
        id : 2,
        username : 'Changseop',
        comment : 'Woops... I wanna sleep'
    },
    {
        id : 3,
        username : 'Rola',
        comment : 'Hey, What are you doing?'
    },
    {
        id : 4,
        username : 'Gamma',
        comment : 'Please, Keep going'
    }
];

app.get('/comments', (req,res) => {
    res.render('comments/index', {comments});
})

//create 
//라우트 2개가 필요함 
// 폼이 어딘가로 제출되는데 데이터를 post요청으로 거기로 보내야하기 때문
app.get('/comments/new', (req,res) => { //폼을 보여주는 get 라우트
    res.render('comments/new');
})
app.post('/comments', (req,res) => {
    const {username, comment} = req.body;
    comments.push({username, comment});
    res.redirect('/comments');  //302 반응 후 리다이렉트
})

//Show, 중첩라우트
app.get('/comments/:id', (req,res) => {
    const {id} = req.params;
    const comment = comments.find(c => c.id === parseInt(id));
    res.render('comments/show', {comment});
})

// Update를 위한 HTTP 동사는 PUT, PATCH 이 있다
// PUT은 전체 내용 업데이트 용도
// PATCH 은 부분적으로 가능, 해당 동사는 PUT과 다르게 페이로드 포함
app.patch('/comments/:id', (req,res) => {
    const {id} = req.params;
    const newCommentText = req.body.comment;
    const foundComment = comments.find(c => c.id === parseInt(id));
    foundComment.comment = newCommentText;
})

//delete
app.delete('/comments/:id', (req,res) => {
    const {id} = req.params;
    comments = comments.filter(c => c.id !== id);
    res.redirect('/comments');
})

app.get('/tacos', (req,res) => {
    console.log('get send !');
})

app.post('/tacos', (req,res) => {
    const {meat, qty}  = req.body;
    res.send(`OK, here your are ${qty} ${meat} tacos`);
})

app.listen(3000,  () => {
    console.log("ON PORT 3000");
})

```

### MongoDB

+ SQL vs NoSQL
    - SQL
        + Structured Query Language
        + MySQL, Postgres, Oracle, etc.
        + 관계형 데이터베이스
        + 스키마와 테이블을 세팅해야 데이터 추가 가능
    - NoSQL
        + 포괄적임
        + 구조화를 따르지 않아 유형이 다양함
        + MongoDB, CouchDB, Redis, Neo4j
+ Why MongoDB?
    -  굉장히 빠르고 JS를 배웠다면 상당히 쉬운 난이도

    